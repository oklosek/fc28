esphome:
  name: boneio1

esp32:
  board: esp32dev

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  power_pin: GPIO5
  phy_addr: 0
  clk_mode: GPIO0_IN
  manual_ip:
    static_ip: !secret ethernet_ip
    gateway: !secret ethernet_gateway
    subnet: !secret ethernet_subnet
    dns1: !secret ethernet_dns

mqtt:
  broker: !secret mqtt_broker   # lokalny broker (R1000/RPi)
  topic_prefix: boneio/1
  on_message:
    # Komendy otwierania/zamykania otrzymywane z backendu
    # Jedna definicja obsługuje parę tematów UP/DOWN dzięki skryptowi handle_cover_command
    - topic: boneio/1/cover/vent1/+
      then:
        - script.execute:
            id: handle_cover_command
            up_switch: vent1_up
            down_switch: vent1_down
            direction: !lambda 'return topic.substr(topic.find_last_of("/") + 1);'
            state: !lambda 'return payload == "ON";'

    - topic: boneio/1/cover/vent2/+
      then:
        - script.execute:
            id: handle_cover_command
            up_switch: vent2_up
            down_switch: vent2_down
            direction: !lambda 'return topic.substr(topic.find_last_of("/") + 1);'
            state: !lambda 'return payload == "ON";'

    - topic: boneio/1/cover/vent3/+
      then:
        - script.execute:
            id: handle_cover_command
            up_switch: vent3_up
            down_switch: vent3_down
            direction: !lambda 'return topic.substr(topic.find_last_of("/") + 1);'
            state: !lambda 'return payload == "ON";'

# Skrypt obsługuje pary tematów UP/DOWN dla wietrzników
script:
  - id: handle_cover_command
    parameters:
      up_switch: switch
      down_switch: switch
      direction: string
      state: bool
    then:
      - lambda: |-
          if (direction == "up") {
            if (state) {
              up_switch->turn_on();
            } else {
              up_switch->turn_off();
            }
          } else {
            if (state) {
              down_switch->turn_on();
            } else {
              down_switch->turn_off();
            }
          }

# Przekaźniki (przykład – dostosuj do pinów BONEIO)
switch:
  - platform: gpio
    pin: GPIO16
    id: vent1_up
    name: "vent1_up"
    interlock: [vent1_down]
  - platform: gpio
    pin: GPIO17
    id: vent1_down
    name: "vent1_down"
    interlock: [vent1_up]
  - platform: gpio
    pin: GPIO18
    id: vent2_up
    name: "vent2_up"
    interlock: [vent2_down]
  - platform: gpio
    pin: GPIO19
    id: vent2_down
    name: "vent2_down"
    interlock: [vent2_up]
  - platform: gpio
    pin: GPIO21
    id: vent3_up
    name: "vent3_up"
    interlock: [vent3_down]
  - platform: gpio
    pin: GPIO22
    id: vent3_down
    name: "vent3_down"
    interlock: [vent3_up]

binary_sensor:
  # Błąd krańcowy/awaria – ODD inputs: IN1, IN3, IN5...
  - platform: gpio
    pin: GPIO32
    name: "vent1_error"
    id: vent1_error
    filters:
      - invert:
    on_press:
      - mqtt.publish:
          topic: boneio/1/in/vent1_error
          payload: "1"
    on_release:
      - mqtt.publish:
          topic: boneio/1/in/vent1_error
          payload: "0"

  - platform: gpio
    pin: GPIO33
    name: "vent2_error"
    id: vent2_error
    filters:
      - invert:
    on_press:
      - mqtt.publish:
          topic: boneio/1/in/vent2_error
          payload: "1"
    on_release:
      - mqtt.publish:
          topic: boneio/1/in/vent2_error
          payload: "0"

  - platform: gpio
    pin: GPIO25
    name: "vent3_error"
    id: vent3_error
    filters:
      - invert:
    on_press:
      - mqtt.publish:
          topic: boneio/1/in/vent3_error
          payload: "1"
    on_release:
      - mqtt.publish:
          topic: boneio/1/in/vent3_error
          payload: "0"

